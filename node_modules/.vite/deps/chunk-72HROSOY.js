import {
  _extends,
  _objectWithoutPropertiesLoose,
  init_extends,
  init_objectWithoutPropertiesLoose
} from "./chunk-6AR3UVYR.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/react-spring/web.js
init_extends();
init_objectWithoutPropertiesLoose();
var import_react = __toESM(require_react());
var is = {
  arr: Array.isArray,
  obj: (a) => Object.prototype.toString.call(a) === "[object Object]",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0,
  nul: (a) => a === null,
  set: (a) => a instanceof Set,
  map: (a) => a instanceof Map,
  equ(a, b) {
    if (typeof a !== typeof b)
      return false;
    if (is.str(a) || is.num(a))
      return a === b;
    if (is.obj(a) && is.obj(b) && Object.keys(a).length + Object.keys(b).length === 0)
      return true;
    let i;
    for (i in a)
      if (!(i in b))
        return false;
    for (i in b)
      if (a[i] !== b[i])
        return false;
    return is.und(i) ? a === b : true;
  }
};
function merge(target, lowercase) {
  if (lowercase === void 0) {
    lowercase = true;
  }
  return (object) => (is.arr(object) ? object : Object.keys(object)).reduce((acc, element) => {
    const key = lowercase ? element[0].toLowerCase() + element.substring(1) : element;
    acc[key] = target(key);
    return acc;
  }, target);
}
function useForceUpdate() {
  const _useState = (0, import_react.useState)(false), f = _useState[1];
  const forceUpdate = (0, import_react.useCallback)(() => f((v) => !v), []);
  return forceUpdate;
}
function withDefault(value, defaultValue) {
  return is.und(value) || is.nul(value) ? defaultValue : value;
}
function toArray(a) {
  return !is.und(a) ? is.arr(a) ? a : [a] : [];
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return is.fun(obj) ? obj(...args) : obj;
}
function getForwardProps(props) {
  const to = props.to, from = props.from, config2 = props.config, onStart = props.onStart, onRest = props.onRest, onFrame = props.onFrame, children = props.children, reset = props.reset, reverse = props.reverse, force = props.force, immediate = props.immediate, delay = props.delay, attach = props.attach, destroyed = props.destroyed, interpolateTo2 = props.interpolateTo, ref = props.ref, lazy = props.lazy, forward = _objectWithoutPropertiesLoose(props, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
  return forward;
}
function interpolateTo(props) {
  const forward = getForwardProps(props);
  if (is.und(forward))
    return _extends({
      to: forward
    }, props);
  const rest = Object.keys(props).reduce((a, k) => !is.und(forward[k]) ? a : _extends({}, a, {
    [k]: props[k]
  }), {});
  return _extends({
    to: forward
  }, rest);
}
function handleRef(ref, forward) {
  if (forward) {
    if (is.fun(forward))
      forward(ref);
    else if (is.obj(forward)) {
      forward.current = ref;
    }
  }
  return ref;
}
var Animated = class {
  constructor() {
    this.payload = void 0;
    this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(child) {
    if (this.children.length === 0)
      this.attach();
    this.children.push(child);
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    this.children.splice(index, 1);
    if (this.children.length === 0)
      this.detach();
  }
};
var AnimatedArray = class extends Animated {
  constructor() {
    super(...arguments);
    this.payload = [];
    this.attach = () => this.payload.forEach((p) => p instanceof Animated && p.addChild(this));
    this.detach = () => this.payload.forEach((p) => p instanceof Animated && p.removeChild(this));
  }
};
var AnimatedObject = class extends Animated {
  constructor() {
    super(...arguments);
    this.payload = {};
    this.attach = () => Object.values(this.payload).forEach((s) => s instanceof Animated && s.addChild(this));
    this.detach = () => Object.values(this.payload).forEach((s) => s instanceof Animated && s.removeChild(this));
  }
  getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }
    const payload = {};
    for (const key in this.payload) {
      const value = this.payload[key];
      if (animated && !(value instanceof Animated))
        continue;
      payload[key] = value instanceof Animated ? value[animated ? "getAnimatedValue" : "getValue"]() : value;
    }
    return payload;
  }
  getAnimatedValue() {
    return this.getValue(true);
  }
};
var applyAnimatedValues;
function injectApplyAnimatedValues(fn, transform) {
  applyAnimatedValues = {
    fn,
    transform
  };
}
var colorNames;
function injectColorNames(names) {
  colorNames = names;
}
var requestFrame = (cb) => typeof window !== "undefined" ? window.requestAnimationFrame(cb) : -1;
var cancelFrame = (id) => {
  typeof window !== "undefined" && window.cancelAnimationFrame(id);
};
function injectFrame(raf, caf) {
  requestFrame = raf;
  cancelFrame = caf;
}
var interpolation;
function injectStringInterpolator(fn) {
  interpolation = fn;
}
var now = () => Date.now();
function injectNow(nowFn) {
  now = nowFn;
}
var defaultElement;
function injectDefaultElement(el) {
  defaultElement = el;
}
var animatedApi = (node) => node.current;
function injectAnimatedApi(fn) {
  animatedApi = fn;
}
var createAnimatedStyle;
function injectCreateAnimatedStyle(factory) {
  createAnimatedStyle = factory;
}
var manualFrameloop;
function injectManualFrameloop(callback) {
  manualFrameloop = callback;
}
var Globals = Object.freeze({
  get applyAnimatedValues() {
    return applyAnimatedValues;
  },
  injectApplyAnimatedValues,
  get colorNames() {
    return colorNames;
  },
  injectColorNames,
  get requestFrame() {
    return requestFrame;
  },
  get cancelFrame() {
    return cancelFrame;
  },
  injectFrame,
  get interpolation() {
    return interpolation;
  },
  injectStringInterpolator,
  get now() {
    return now;
  },
  injectNow,
  get defaultElement() {
    return defaultElement;
  },
  injectDefaultElement,
  get animatedApi() {
    return animatedApi;
  },
  injectAnimatedApi,
  get createAnimatedStyle() {
    return createAnimatedStyle;
  },
  injectCreateAnimatedStyle,
  get manualFrameloop() {
    return manualFrameloop;
  },
  injectManualFrameloop
});
var AnimatedProps = class extends AnimatedObject {
  constructor(props, callback) {
    super();
    this.update = void 0;
    this.payload = !props.style ? props : _extends({}, props, {
      style: createAnimatedStyle(props.style)
    });
    this.update = callback;
    this.attach();
  }
};
var isFunctionComponent = (val) => is.fun(val) && !(val.prototype instanceof import_react.default.Component);
var createAnimatedComponent = (Component) => {
  const AnimatedComponent = (0, import_react.forwardRef)((props, ref) => {
    const forceUpdate = useForceUpdate();
    const mounted = (0, import_react.useRef)(true);
    const propsAnimated = (0, import_react.useRef)(null);
    const node = (0, import_react.useRef)(null);
    const attachProps = (0, import_react.useCallback)((props2) => {
      const oldPropsAnimated = propsAnimated.current;
      const callback = () => {
        let didUpdate = false;
        if (node.current) {
          didUpdate = applyAnimatedValues.fn(node.current, propsAnimated.current.getAnimatedValue());
        }
        if (!node.current || didUpdate === false) {
          forceUpdate();
        }
      };
      propsAnimated.current = new AnimatedProps(props2, callback);
      oldPropsAnimated && oldPropsAnimated.detach();
    }, []);
    (0, import_react.useEffect)(() => () => {
      mounted.current = false;
      propsAnimated.current && propsAnimated.current.detach();
    }, []);
    (0, import_react.useImperativeHandle)(ref, () => animatedApi(node, mounted, forceUpdate));
    attachProps(props);
    const _getValue = propsAnimated.current.getValue(), scrollTop = _getValue.scrollTop, scrollLeft = _getValue.scrollLeft, animatedProps = _objectWithoutPropertiesLoose(_getValue, ["scrollTop", "scrollLeft"]);
    const refFn = isFunctionComponent(Component) ? void 0 : (childRef) => node.current = handleRef(childRef, ref);
    return import_react.default.createElement(Component, _extends({}, animatedProps, {
      ref: refFn
    }));
  });
  return AnimatedComponent;
};
var active = false;
var controllers = /* @__PURE__ */ new Set();
var update = () => {
  if (!active)
    return false;
  let time = now();
  for (let controller of controllers) {
    let isActive = false;
    for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {
      let config2 = controller.configs[configIdx];
      let endOfAnimation, lastTime;
      for (let valIdx = 0; valIdx < config2.animatedValues.length; valIdx++) {
        let animation = config2.animatedValues[valIdx];
        if (animation.done)
          continue;
        let from = config2.fromValues[valIdx];
        let to = config2.toValues[valIdx];
        let position = animation.lastPosition;
        let isAnimated = to instanceof Animated;
        let velocity = Array.isArray(config2.initialVelocity) ? config2.initialVelocity[valIdx] : config2.initialVelocity;
        if (isAnimated)
          to = to.getValue();
        if (config2.immediate) {
          animation.setValue(to);
          animation.done = true;
          continue;
        }
        if (typeof from === "string" || typeof to === "string") {
          animation.setValue(to);
          animation.done = true;
          continue;
        }
        if (config2.duration !== void 0) {
          position = from + config2.easing((time - animation.startTime) / config2.duration) * (to - from);
          endOfAnimation = time >= animation.startTime + config2.duration;
        } else if (config2.decay) {
          position = from + velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - animation.startTime)));
          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;
          if (endOfAnimation)
            to = position;
        } else {
          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;
          velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config2.initialVelocity;
          if (time > lastTime + 64)
            lastTime = time;
          let numSteps = Math.floor(time - lastTime);
          for (let i = 0; i < numSteps; ++i) {
            let force = -config2.tension * (position - to);
            let damping = -config2.friction * velocity;
            let acceleration = (force + damping) / config2.mass;
            velocity = velocity + acceleration * 1 / 1e3;
            position = position + velocity * 1 / 1e3;
          }
          let isOvershooting = config2.clamp && config2.tension !== 0 ? from < to ? position > to : position < to : false;
          let isVelocity = Math.abs(velocity) <= config2.precision;
          let isDisplacement = config2.tension !== 0 ? Math.abs(to - position) <= config2.precision : true;
          endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          animation.lastVelocity = velocity;
          animation.lastTime = time;
        }
        if (isAnimated && !config2.toValues[valIdx].done)
          endOfAnimation = false;
        if (endOfAnimation) {
          if (animation.value !== to)
            position = to;
          animation.done = true;
        } else
          isActive = true;
        animation.setValue(position);
        animation.lastPosition = position;
      }
      if (controller.props.onFrame)
        controller.values[config2.name] = config2.interpolation.getValue();
    }
    if (controller.props.onFrame)
      controller.props.onFrame(controller.values);
    if (!isActive) {
      controllers.delete(controller);
      controller.stop(true);
    }
  }
  if (controllers.size) {
    if (manualFrameloop)
      manualFrameloop();
    else
      requestFrame(update);
  } else {
    active = false;
  }
  return active;
};
var start = (controller) => {
  if (!controllers.has(controller))
    controllers.add(controller);
  if (!active) {
    active = true;
    if (manualFrameloop)
      requestFrame(manualFrameloop);
    else
      requestFrame(update);
  }
};
var stop = (controller) => {
  if (controllers.has(controller))
    controllers.delete(controller);
};
function createInterpolator(range, output, extrapolate) {
  if (typeof range === "function") {
    return range;
  }
  if (Array.isArray(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (interpolation && typeof range.output[0] === "string") {
    return interpolation(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t) => t);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
  };
}
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}
var AnimatedInterpolation = class extends AnimatedArray {
  constructor(parents, range, output, extrapolate) {
    super();
    this.calc = void 0;
    this.payload = parents instanceof AnimatedArray && !(parents instanceof AnimatedInterpolation) ? parents.getPayload() : Array.isArray(parents) ? parents : [parents];
    this.calc = createInterpolator(range, output, extrapolate);
  }
  getValue() {
    return this.calc(...this.payload.map((value) => value.getValue()));
  }
  updateConfig(range, output, extrapolate) {
    this.calc = createInterpolator(range, output, extrapolate);
  }
  interpolate(range, output, extrapolate) {
    return new AnimatedInterpolation(this, range, output, extrapolate);
  }
};
var interpolate$1 = (parents, range, output) => parents && new AnimatedInterpolation(parents, range, output);
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};
function useChain(refs, timeSteps, timeFrame) {
  if (timeFrame === void 0) {
    timeFrame = 1e3;
  }
  const previous = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (is.equ(refs, previous.current))
      refs.forEach((_ref) => {
        let current = _ref.current;
        return current && current.start();
      });
    else if (timeSteps) {
      refs.forEach((_ref2, index) => {
        let current = _ref2.current;
        if (current) {
          const ctrls = current.controllers;
          if (ctrls.length) {
            const t = timeFrame * timeSteps[index];
            ctrls.forEach((ctrl) => {
              ctrl.queue = ctrl.queue.map((e) => _extends({}, e, {
                delay: e.delay + t
              }));
              ctrl.start();
            });
          }
        }
      });
    } else
      refs.reduce((q, _ref3, rI) => {
        let current = _ref3.current;
        return q = q.then(() => current.start());
      }, Promise.resolve());
    previous.current = refs;
  });
}
function addAnimatedStyles(node, styles) {
  if ("update" in node) {
    styles.add(node);
  } else {
    node.getChildren().forEach((child) => addAnimatedStyles(child, styles));
  }
}
var AnimatedValue = class extends Animated {
  constructor(_value) {
    var _this;
    super();
    _this = this;
    this.animatedStyles = /* @__PURE__ */ new Set();
    this.value = void 0;
    this.startPosition = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.startTime = void 0;
    this.lastTime = void 0;
    this.done = false;
    this.setValue = function(value, flush) {
      if (flush === void 0) {
        flush = true;
      }
      _this.value = value;
      if (flush)
        _this.flush();
    };
    this.value = _value;
    this.startPosition = _value;
    this.lastPosition = _value;
  }
  flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }
    this.animatedStyles.forEach((animatedStyle) => animatedStyle.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(range, output, extrapolate) {
    return new AnimatedInterpolation(this, range, output, extrapolate);
  }
};
var AnimatedValueArray = class extends AnimatedArray {
  constructor(values) {
    super();
    this.payload = values.map((n) => new AnimatedValue(n));
  }
  setValue(value, flush) {
    if (flush === void 0) {
      flush = true;
    }
    if (Array.isArray(value)) {
      if (value.length === this.payload.length) {
        value.forEach((v, i) => this.payload[i].setValue(v, flush));
      }
    } else {
      this.payload.forEach((p) => p.setValue(value, flush));
    }
  }
  getValue() {
    return this.payload.map((v) => v.getValue());
  }
  interpolate(range, output) {
    return new AnimatedInterpolation(this, range, output);
  }
};
var G = 0;
var Controller = class {
  constructor() {
    this.id = void 0;
    this.idle = true;
    this.hasChanged = false;
    this.guid = 0;
    this.local = 0;
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.values = {};
    this.configs = [];
    this.listeners = [];
    this.queue = [];
    this.localQueue = void 0;
    this.getValues = () => this.interpolations;
    this.id = G++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(args) {
    if (!args)
      return this;
    const _ref = interpolateTo(args), _ref$delay = _ref.delay, delay = _ref$delay === void 0 ? 0 : _ref$delay, to = _ref.to, props = _objectWithoutPropertiesLoose(_ref, ["delay", "to"]);
    if (is.arr(to) || is.fun(to)) {
      this.queue.push(_extends({}, props, {
        delay,
        to
      }));
    } else if (to) {
      let ops = {};
      Object.entries(to).forEach((_ref2) => {
        let k = _ref2[0], v = _ref2[1];
        const entry = _extends({
          to: {
            [k]: v
          },
          delay: callProp(delay, k)
        }, props);
        const previous = ops[entry.delay] && ops[entry.delay].to;
        ops[entry.delay] = _extends({}, ops[entry.delay], entry, {
          to: _extends({}, previous, entry.to)
        });
      });
      this.queue = Object.values(ops);
    }
    this.queue = this.queue.sort((a, b) => a.delay - b.delay);
    this.diff(props);
    return this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(onEnd) {
    if (this.queue.length) {
      this.idle = false;
      if (this.localQueue) {
        this.localQueue.forEach((_ref3) => {
          let _ref3$from = _ref3.from, from = _ref3$from === void 0 ? {} : _ref3$from, _ref3$to = _ref3.to, to = _ref3$to === void 0 ? {} : _ref3$to;
          if (is.obj(from))
            this.merged = _extends({}, from, this.merged);
          if (is.obj(to))
            this.merged = _extends({}, this.merged, to);
        });
      }
      const local = this.local = ++this.guid;
      const queue = this.localQueue = this.queue;
      this.queue = [];
      queue.forEach((_ref4, index) => {
        let delay = _ref4.delay, props = _objectWithoutPropertiesLoose(_ref4, ["delay"]);
        const cb = (finished) => {
          if (index === queue.length - 1 && local === this.guid && finished) {
            this.idle = true;
            if (this.props.onRest)
              this.props.onRest(this.merged);
          }
          if (onEnd)
            onEnd();
        };
        let async = is.arr(props.to) || is.fun(props.to);
        if (delay) {
          setTimeout(() => {
            if (local === this.guid) {
              if (async)
                this.runAsync(props, cb);
              else
                this.diff(props).start(cb);
            }
          }, delay);
        } else if (async)
          this.runAsync(props, cb);
        else
          this.diff(props).start(cb);
      });
    } else {
      if (is.fun(onEnd))
        this.listeners.push(onEnd);
      if (this.props.onStart)
        this.props.onStart();
      start(this);
    }
    return this;
  }
  stop(finished) {
    this.listeners.forEach((onEnd) => onEnd(finished));
    this.listeners = [];
    return this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(finished) {
    this.stop(true);
    if (finished)
      stop(this);
    return this;
  }
  runAsync(_ref5, onEnd) {
    var _this = this;
    let delay = _ref5.delay, props = _objectWithoutPropertiesLoose(_ref5, ["delay"]);
    const local = this.local;
    let queue = Promise.resolve(void 0);
    if (is.arr(props.to)) {
      for (let i = 0; i < props.to.length; i++) {
        const index = i;
        const fresh = _extends({}, props, interpolateTo(props.to[index]));
        if (is.arr(fresh.config))
          fresh.config = fresh.config[index];
        queue = queue.then(() => {
          if (local === this.guid)
            return new Promise((r) => this.diff(fresh).start(r));
        });
      }
    } else if (is.fun(props.to)) {
      let index = 0;
      let last;
      queue = queue.then(() => props.to(
        // next(props)
        (p) => {
          const fresh = _extends({}, props, interpolateTo(p));
          if (is.arr(fresh.config))
            fresh.config = fresh.config[index];
          index++;
          if (local === this.guid)
            return last = new Promise((r) => this.diff(fresh).start(r));
          return;
        },
        // cancel()
        function(finished) {
          if (finished === void 0) {
            finished = true;
          }
          return _this.stop(finished);
        }
      ).then(() => last));
    }
    queue.then(onEnd);
  }
  diff(props) {
    this.props = _extends({}, this.props, props);
    let _this$props = this.props, _this$props$from = _this$props.from, from = _this$props$from === void 0 ? {} : _this$props$from, _this$props$to = _this$props.to, to = _this$props$to === void 0 ? {} : _this$props$to, _this$props$config = _this$props.config, config2 = _this$props$config === void 0 ? {} : _this$props$config, reverse = _this$props.reverse, attach = _this$props.attach, reset = _this$props.reset, immediate = _this$props.immediate;
    if (reverse) {
      var _ref6 = [to, from];
      from = _ref6[0];
      to = _ref6[1];
    }
    this.merged = _extends({}, from, this.merged, to);
    this.hasChanged = false;
    let target = attach && attach(this);
    this.animations = Object.entries(this.merged).reduce((acc, _ref7) => {
      let name = _ref7[0], value = _ref7[1];
      let entry = acc[name] || {};
      const isNumber = is.num(value);
      const isString = is.str(value) && !value.startsWith("#") && !/\d/.test(value) && !colorNames[value];
      const isArray = is.arr(value);
      const isInterpolation = !isNumber && !isArray && !isString;
      let fromValue = !is.und(from[name]) ? from[name] : value;
      let toValue = isNumber || isArray ? value : isString ? value : 1;
      let toConfig = callProp(config2, name);
      if (target)
        toValue = target.animations[name].parent;
      let parent = entry.parent, interpolation$$1 = entry.interpolation, toValues = toArray(target ? toValue.getPayload() : toValue), animatedValues;
      let newValue = value;
      if (isInterpolation)
        newValue = interpolation({
          range: [0, 1],
          output: [value, value]
        })(1);
      let currentValue = interpolation$$1 && interpolation$$1.getValue();
      const isFirst = is.und(parent);
      const isActive = !isFirst && entry.animatedValues.some((v) => !v.done);
      const currentValueDiffersFromGoal = !is.equ(newValue, currentValue);
      const hasNewGoal = !is.equ(newValue, entry.previous);
      const hasNewConfig = !is.equ(toConfig, entry.config);
      if (reset || hasNewGoal && currentValueDiffersFromGoal || hasNewConfig) {
        if (isNumber || isString)
          parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);
        else if (isArray)
          parent = interpolation$$1 = entry.parent || new AnimatedValueArray(fromValue);
        else if (isInterpolation) {
          let prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);
          prev = prev !== void 0 && !reset ? prev : fromValue;
          if (entry.parent) {
            parent = entry.parent;
            parent.setValue(0, false);
          } else
            parent = new AnimatedValue(0);
          const range = {
            output: [prev, value]
          };
          if (entry.interpolation) {
            interpolation$$1 = entry.interpolation;
            entry.interpolation.updateConfig(range);
          } else
            interpolation$$1 = parent.interpolate(range);
        }
        toValues = toArray(target ? toValue.getPayload() : toValue);
        animatedValues = toArray(parent.getPayload());
        if (reset && !isInterpolation)
          parent.setValue(fromValue, false);
        this.hasChanged = true;
        animatedValues.forEach((value2) => {
          value2.startPosition = value2.value;
          value2.lastPosition = value2.value;
          value2.lastVelocity = isActive ? value2.lastVelocity : void 0;
          value2.lastTime = isActive ? value2.lastTime : void 0;
          value2.startTime = now();
          value2.done = false;
          value2.animatedStyles.clear();
        });
        if (callProp(immediate, name)) {
          parent.setValue(isInterpolation ? toValue : value, false);
        }
        return _extends({}, acc, {
          [name]: _extends({}, entry, {
            name,
            parent,
            interpolation: interpolation$$1,
            animatedValues,
            toValues,
            previous: newValue,
            config: toConfig,
            fromValues: toArray(parent.getValue()),
            immediate: callProp(immediate, name),
            initialVelocity: withDefault(toConfig.velocity, 0),
            clamp: withDefault(toConfig.clamp, false),
            precision: withDefault(toConfig.precision, 0.01),
            tension: withDefault(toConfig.tension, 170),
            friction: withDefault(toConfig.friction, 26),
            mass: withDefault(toConfig.mass, 1),
            duration: toConfig.duration,
            easing: withDefault(toConfig.easing, (t) => t),
            decay: toConfig.decay
          })
        });
      } else {
        if (!currentValueDiffersFromGoal) {
          if (isInterpolation) {
            parent.setValue(1, false);
            interpolation$$1.updateConfig({
              output: [newValue, newValue]
            });
          }
          parent.done = true;
          this.hasChanged = true;
          return _extends({}, acc, {
            [name]: _extends({}, acc[name], {
              previous: newValue
            })
          });
        }
        return acc;
      }
    }, this.animations);
    if (this.hasChanged) {
      this.configs = Object.values(this.animations);
      this.values = {};
      this.interpolations = {};
      for (let key in this.animations) {
        this.interpolations[key] = this.animations[key].interpolation;
        this.values[key] = this.animations[key].interpolation.getValue();
      }
    }
    return this;
  }
  destroy() {
    this.stop();
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.values = {};
    this.configs = [];
    this.local = 0;
  }
};
var useSprings = (length, props) => {
  const mounted = (0, import_react.useRef)(false);
  const ctrl = (0, import_react.useRef)();
  const isFn = is.fun(props);
  const _useMemo = (0, import_react.useMemo)(() => {
    if (ctrl.current) {
      ctrl.current.map((c) => c.destroy());
      ctrl.current = void 0;
    }
    let ref2;
    return [new Array(length).fill().map((_, i) => {
      const ctrl2 = new Controller();
      const newProps = isFn ? callProp(props, i, ctrl2) : props[i];
      if (i === 0)
        ref2 = newProps.ref;
      ctrl2.update(newProps);
      if (!ref2)
        ctrl2.start();
      return ctrl2;
    }), ref2];
  }, [length]), controllers2 = _useMemo[0], ref = _useMemo[1];
  ctrl.current = controllers2;
  const api = (0, import_react.useImperativeHandle)(ref, () => ({
    start: () => Promise.all(ctrl.current.map((c) => new Promise((r) => c.start(r)))),
    stop: (finished) => ctrl.current.forEach((c) => c.stop(finished)),
    get controllers() {
      return ctrl.current;
    }
  }));
  const updateCtrl = (0, import_react.useMemo)(() => (updateProps) => ctrl.current.map((c, i) => {
    c.update(isFn ? callProp(updateProps, i, c) : updateProps[i]);
    if (!ref)
      c.start();
  }), [length]);
  (0, import_react.useEffect)(() => {
    if (mounted.current) {
      if (!isFn)
        updateCtrl(props);
    } else if (!ref)
      ctrl.current.forEach((c) => c.start());
  });
  (0, import_react.useEffect)(() => (mounted.current = true, () => ctrl.current.forEach((c) => c.destroy())), []);
  const propValues = ctrl.current.map((c) => c.getValues());
  return isFn ? [propValues, updateCtrl, (finished) => ctrl.current.forEach((c) => c.pause(finished))] : propValues;
};
var useSpring = (props) => {
  const isFn = is.fun(props);
  const _useSprings = useSprings(1, isFn ? props : [props]), result = _useSprings[0], set = _useSprings[1], pause = _useSprings[2];
  return isFn ? [result[0], set, pause] : result;
};
var useTrail = (length, props) => {
  const mounted = (0, import_react.useRef)(false);
  const isFn = is.fun(props);
  const updateProps = callProp(props);
  const instances = (0, import_react.useRef)();
  const _useSprings = useSprings(length, (i, ctrl) => {
    if (i === 0)
      instances.current = [];
    instances.current.push(ctrl);
    return _extends({}, updateProps, {
      config: callProp(updateProps.config, i),
      attach: i > 0 && (() => instances.current[i - 1])
    });
  }), result = _useSprings[0], set = _useSprings[1], pause = _useSprings[2];
  const updateCtrl = (0, import_react.useMemo)(() => (props2) => set((i, ctrl) => {
    const last = props2.reverse ? i === 0 : length - 1 === i;
    const attachIdx = props2.reverse ? i + 1 : i - 1;
    const attachController = instances.current[attachIdx];
    return _extends({}, props2, {
      config: callProp(props2.config || updateProps.config, i),
      attach: attachController && (() => attachController)
    });
  }), [length, updateProps.reverse]);
  (0, import_react.useEffect)(() => void (mounted.current && !isFn && updateCtrl(props)));
  (0, import_react.useEffect)(() => void (mounted.current = true), []);
  return isFn ? [result, updateCtrl, pause] : result;
};
var guid = 0;
var ENTER = "enter";
var LEAVE = "leave";
var UPDATE = "update";
var mapKeys = (items, keys) => (typeof keys === "function" ? items.map(keys) : toArray(keys)).map(String);
var get = (props) => {
  let items = props.items, _props$keys = props.keys, keys = _props$keys === void 0 ? (item) => item : _props$keys, rest = _objectWithoutPropertiesLoose(props, ["items", "keys"]);
  items = toArray(items !== void 0 ? items : null);
  return _extends({
    items,
    keys: mapKeys(items, keys)
  }, rest);
};
function useTransition(input, keyTransform, config2) {
  const props = _extends({
    items: input,
    keys: keyTransform || ((i) => i)
  }, config2);
  const _get = get(props), _get$lazy = _get.lazy, lazy = _get$lazy === void 0 ? false : _get$lazy, _get$unique = _get.unique, _get$reset = _get.reset, reset = _get$reset === void 0 ? false : _get$reset, enter = _get.enter, leave = _get.leave, update2 = _get.update, onDestroyed = _get.onDestroyed, keys = _get.keys, items = _get.items, onFrame = _get.onFrame, _onRest = _get.onRest, onStart = _get.onStart, ref = _get.ref, extra = _objectWithoutPropertiesLoose(_get, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]);
  const forceUpdate = useForceUpdate();
  const mounted = (0, import_react.useRef)(false);
  const state = (0, import_react.useRef)({
    mounted: false,
    first: true,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!props.ref,
    instances: !mounted.current && /* @__PURE__ */ new Map(),
    forceUpdate
  });
  (0, import_react.useImperativeHandle)(props.ref, () => ({
    start: () => Promise.all(Array.from(state.current.instances).map((_ref) => {
      let c = _ref[1];
      return new Promise((r) => c.start(r));
    })),
    stop: (finished) => Array.from(state.current.instances).forEach((_ref2) => {
      let c = _ref2[1];
      return c.stop(finished);
    }),
    get controllers() {
      return Array.from(state.current.instances).map((_ref3) => {
        let c = _ref3[1];
        return c;
      });
    }
  }));
  state.current = diffItems(state.current, props);
  if (state.current.changed) {
    state.current.transitions.forEach((transition) => {
      const slot = transition.slot, from = transition.from, to = transition.to, config3 = transition.config, trail = transition.trail, key = transition.key, item = transition.item;
      if (!state.current.instances.has(key))
        state.current.instances.set(key, new Controller());
      const ctrl = state.current.instances.get(key);
      const newProps = _extends({}, extra, {
        to,
        from,
        config: config3,
        ref,
        onRest: (values) => {
          if (state.current.mounted) {
            if (transition.destroyed) {
              if (!ref && !lazy)
                cleanUp(state, key);
              if (onDestroyed)
                onDestroyed(item);
            }
            const curInstances = Array.from(state.current.instances);
            const active2 = curInstances.some((_ref4) => {
              let c = _ref4[1];
              return !c.idle;
            });
            if (!active2 && (ref || lazy) && state.current.deleted.length > 0)
              cleanUp(state);
            if (_onRest)
              _onRest(item, slot, values);
          }
        },
        onStart: onStart && (() => onStart(item, slot)),
        onFrame: onFrame && ((values) => onFrame(item, slot, values)),
        delay: trail,
        reset: reset && slot === ENTER
        // Update controller
      });
      ctrl.update(newProps);
      if (!state.current.paused)
        ctrl.start();
    });
  }
  (0, import_react.useEffect)(() => {
    state.current.mounted = mounted.current = true;
    return () => {
      state.current.mounted = mounted.current = false;
      Array.from(state.current.instances).map((_ref5) => {
        let c = _ref5[1];
        return c.destroy();
      });
      state.current.instances.clear();
    };
  }, []);
  return state.current.transitions.map((_ref6) => {
    let item = _ref6.item, slot = _ref6.slot, key = _ref6.key;
    return {
      item,
      key,
      state: slot,
      props: state.current.instances.get(key).getValues()
    };
  });
}
function cleanUp(state, filterKey) {
  const deleted = state.current.deleted;
  for (let _ref7 of deleted) {
    let key = _ref7.key;
    const filter = (t) => t.key !== key;
    if (is.und(filterKey) || filterKey === key) {
      state.current.instances.delete(key);
      state.current.transitions = state.current.transitions.filter(filter);
      state.current.deleted = state.current.deleted.filter(filter);
    }
  }
  state.current.forceUpdate();
}
function diffItems(_ref8, props) {
  let first = _ref8.first, prevProps = _ref8.prevProps, state = _objectWithoutPropertiesLoose(_ref8, ["first", "prevProps"]);
  let _get2 = get(props), items = _get2.items, keys = _get2.keys, initial = _get2.initial, from = _get2.from, enter = _get2.enter, leave = _get2.leave, update2 = _get2.update, _get2$trail = _get2.trail, trail = _get2$trail === void 0 ? 0 : _get2$trail, unique = _get2.unique, config2 = _get2.config, _get2$order = _get2.order, order = _get2$order === void 0 ? [ENTER, LEAVE, UPDATE] : _get2$order;
  let _get3 = get(prevProps), _keys = _get3.keys, _items = _get3.items;
  let current = _extends({}, state.current);
  let deleted = [...state.deleted];
  let currentKeys = Object.keys(current);
  let currentSet = new Set(currentKeys);
  let nextSet = new Set(keys);
  let added = keys.filter((item) => !currentSet.has(item));
  let removed = state.transitions.filter((item) => !item.destroyed && !nextSet.has(item.originalKey)).map((i) => i.originalKey);
  let updated = keys.filter((item) => currentSet.has(item));
  let delay = -trail;
  while (order.length) {
    const changeType = order.shift();
    switch (changeType) {
      case ENTER: {
        added.forEach((key, index) => {
          if (unique && deleted.find((d) => d.originalKey === key))
            deleted = deleted.filter((t) => t.originalKey !== key);
          const keyIndex = keys.indexOf(key);
          const item = items[keyIndex];
          const slot = first && initial !== void 0 ? "initial" : ENTER;
          current[key] = {
            slot,
            originalKey: key,
            key: unique ? String(key) : guid++,
            item,
            trail: delay = delay + trail,
            config: callProp(config2, item, slot),
            from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),
            to: callProp(enter, item)
          };
        });
        break;
      }
      case LEAVE: {
        removed.forEach((key) => {
          const keyIndex = _keys.indexOf(key);
          const item = _items[keyIndex];
          const slot = LEAVE;
          deleted.unshift(_extends({}, current[key], {
            slot,
            destroyed: true,
            left: _keys[Math.max(0, keyIndex - 1)],
            right: _keys[Math.min(_keys.length, keyIndex + 1)],
            trail: delay = delay + trail,
            config: callProp(config2, item, slot),
            to: callProp(leave, item)
          }));
          delete current[key];
        });
        break;
      }
      case UPDATE: {
        updated.forEach((key) => {
          const keyIndex = keys.indexOf(key);
          const item = items[keyIndex];
          const slot = UPDATE;
          current[key] = _extends({}, current[key], {
            item,
            slot,
            trail: delay = delay + trail,
            config: callProp(config2, item, slot),
            to: callProp(update2, item)
          });
        });
        break;
      }
    }
  }
  let out = keys.map((key) => current[key]);
  deleted.forEach((_ref9) => {
    let left = _ref9.left, right = _ref9.right, item = _objectWithoutPropertiesLoose(_ref9, ["left", "right"]);
    let pos;
    if ((pos = out.findIndex((t) => t.originalKey === left)) !== -1)
      pos += 1;
    pos = Math.max(0, pos);
    out = [...out.slice(0, pos), item, ...out.slice(pos)];
  });
  return _extends({}, state, {
    changed: added.length || removed.length || updated.length,
    first: first && added.length === 0,
    transitions: out,
    current,
    deleted,
    prevProps: props
  });
}
var AnimatedStyle = class extends AnimatedObject {
  constructor(style) {
    if (style === void 0) {
      style = {};
    }
    super();
    if (style.transform && !(style.transform instanceof Animated)) {
      style = applyAnimatedValues.transform(style);
    }
    this.payload = style;
  }
};
var colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors.hasOwnProperty(color))
    return colors[color];
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  let r = (int32Color & 4278190080) >>> 24;
  let g = (int32Color & 16711680) >>> 16;
  let b = (int32Color & 65280) >>> 8;
  let a = (int32Color & 255) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
var stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var colorNamesRegex = new RegExp(`(${Object.keys(colors).join("|")})`, "g");
var createStringInterpolator = (config2) => {
  const outputRange = config2.output.map((rangeValue) => rangeValue.replace(colorRegex, colorToRgba)).map((rangeValue) => rangeValue.replace(colorNamesRegex, colorToRgba));
  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach((value) => {
    value.match(stringShapeRegex).forEach((number, i) => outputRanges[i].push(+number));
  });
  const interpolations = outputRange[0].match(stringShapeRegex).map((_value, i) => createInterpolator(_extends({}, config2, {
    output: outputRanges[i]
  })));
  return (input) => {
    let i = 0;
    return outputRange[0].replace(stringShapeRegex, () => interpolations[i++](input)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`);
  };
};
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
injectCreateAnimatedStyle((style) => new AnimatedStyle(style));
injectDefaultElement("div");
injectStringInterpolator(createStringInterpolator);
injectColorNames(colors);
injectApplyAnimatedValues((instance, props) => {
  if (instance.nodeType && instance.setAttribute !== void 0) {
    const style = props.style, children = props.children, scrollTop = props.scrollTop, scrollLeft = props.scrollLeft, attributes = _objectWithoutPropertiesLoose(props, ["style", "children", "scrollTop", "scrollLeft"]);
    const filter = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    if (scrollTop !== void 0)
      instance.scrollTop = scrollTop;
    if (scrollLeft !== void 0)
      instance.scrollLeft = scrollLeft;
    if (children !== void 0)
      instance.textContent = children;
    for (let styleName in style) {
      if (!style.hasOwnProperty(styleName))
        continue;
      var isCustomProperty = styleName.indexOf("--") === 0;
      var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
      if (styleName === "float")
        styleName = "cssFloat";
      if (isCustomProperty)
        instance.style.setProperty(styleName, styleValue);
      else
        instance.style[styleName] = styleValue;
    }
    for (let name in attributes) {
      const dashCase = filter ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n) => "-" + n.toLowerCase()));
      if (typeof instance.getAttribute(dashCase) !== "undefined")
        instance.setAttribute(dashCase, attributes[name]);
    }
    return;
  } else
    return false;
}, (style) => style);
var domElements = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var apply = merge(createAnimatedComponent, false);
var extendedAnimated = apply(domElements);

export {
  Globals,
  update,
  interpolate$1,
  config,
  useChain,
  useSprings,
  useSpring,
  useTrail,
  useTransition,
  apply,
  extendedAnimated
};
//# sourceMappingURL=chunk-72HROSOY.js.map
